# 코루틴

## 스프링 WebFlux의 코루틴 지원

1. 기존의 함수평 패터다임에 익숙하거나 리액터의 다양한 연산자에 대한 학습이 부담 없다면, 리액티브 프로그래밍은 비동기-논블로킹 코드 작성 시 매우 좋은 솔루션이지만, 막상 공부해 보면 러닝커브가 매우 높다.
    1. 어려움으로 인해 안드로이드도 최근엔 RxJava에서 코루틴 기반으로 작성하는 코드가 늘어나고 있고, 서버 측에서도 코루틴을 도입하는 사례가 많아지고 있다.
2. `코루틴(Coroutine)`은 코틀린에서 비동기-논블로킹 프로그래밍을 명령형 스타일로 작성할 수 있도록 도와주는 라이브러리다.
3. 코루틴은 `일시 중단 가능한 함수(suspend function)`를 통해 스레드가 실행을 잠시 중단했다가, 중단한 지점부터 다시 `재개(resume)`할 수 있다.
4. 스프링 MVC, 스프링 WebFlux 모두 코루틴을 지원하여, 의존성만 추가하면 바로 사용 가능
5. 리액티브가 코루틴으로 변환되는 방식
    1. Mono는 suspend 함수로 변환
    2. Flux는 Flow로 변환
6. 코루틴을 사용한 WebClient
    1. 기존 리액티브 코드를 코루틴으로 변환하고 싶다면 `await*` 시작하는 확장 함수를 사용하면 즉시 코루틴으로 변환할 수 있다.
7. Spring Data R2DBC의 ReactiveCrudRepository에서 코루틴 적용
    1. `CoroutineCrudRepository`를 사용하면 `await*` 코드 없이 사용 가능

## 코루틴 기초

1. `runBlocking`은 코루틴을 생성하는 `코루틴 빌더`다.
    1. `runBlocking`으로 감싼 코드는 코루틴 내부의 코드가 수행이 끝날 때까지 스레드가 블로킹된다.
    2. 실행 옵션에 `-Dkotlinx.coroutines.debug`를 붙여주면 코루틴에서 수행되는 스레드는 이름 뒤에 `@coroutine#1`이 붙어있는 것을 볼 수 있다.
    3. 일반적으로 코루틴은 스레드를 차단하지 않고 사용해야 하므로, runBlocking을 사용하는 것은 좋지 않지만 꼭 사용해야 하는 경우가 있다.
        1. 코루틴을 지원하지 않는 경우
            1. 예) 테스트코드, 스프링 배치 등
2. `launch`는 스레드 차단 없이 새 코루틴을 시작하고 결과로 job을 반환하는 코루틴 빌더이다.
    1. launch는 결과를 만들어내지 않는 비동기 작업에 적합하기 때문에 인자로 Unit을 반환하는 람다를 인자로 받는다.
    2. `delay()` 함수는 코루틴 라이브러리에 정의된 일시 중단 함수이며, `Thread.sleep()`과 유사하지만, **현재 스레드를 차단하지 않고 일시 중단 시킨다.**
        1. 이때 일시 중단된 스레드는 코루틴 내에서 다른 일시 중단 함수를 수행한다.
    3. launch를 사용해서 여러 개의 작업을 병렬적으로 수행할 수 있다.
    4. launch가 반환하는 `Job`을 사용해 현재 코루틴의 상태를 확인하거나, 실행 또는 취소도 가능하다.
        1. `job1.cancel()`을 호출해 코루틴을 취소할 수 있다.
        2. `launch(start = CoroutineStart.LAZY)`를 사용해서 `start` 함수를 호출하는 시점에 코루틴을 동작시킬 수 있다.
            1. start 함수를 주석처리하면 launch가 동작하지 않는다.
3. `async` 빌더는 비동기 작업을 통해 결과를 만들어내는 경우에 적합하다.
    1. asnyc는 비동기 작업의 결과로 `Deffered`라는 특별한 인스턴스를 반환하는데 `await`라는 함수를 통해 `async`로 수행한 비동기 작업의 결과를 받아올 수 있다.
    2. 자바 스크립트나 다른 언어의 async-await는 `키워드`인 경우가 보통이지만, 코틀린의 코루틴은 async-await가 `함수`인 점이 차이점이다.
4. `suspend` 함수는 코루틴의 핵심 요소로서 일시 중단이 가능한 함수를 말한다.
    1. **suspend**: `키워드`이다.
    2. suspend 함수는 일반 함수를 마음껏 호출할 수 있지만, 일반 함수에선 suspend 함수를 호출할 수 없다.
        1. **호출하는 함수에 suspend 키워드를 붙여주면 된다.**
    3. suspend 함수에서 async, launch와 같은 코루틴 빌더를 사용하려면 `코루틴 스코프(coroutineScope)`를 사용한다.
        1. **coroutineScope를 사용하면 runBlocking과 다르게 현재 스레드가 차단되지 않고 코루틴이 동작한다.**
5. `Flow`는 코루틴에서 리액티브 프로그래밍 스타일로 작성할 수 있도록 만들어진 API다.
    1. 코루틴의 `suspend` 함수는 단일 값을 비동기로 반환하지만, `Flow`를 사용하면 여러 개의 값을 반환할 수 있다.
    2. 리액티브 스트림과 같이 `Terminal Operator(최종 연산자)`인 `collect`를 호출하지 않으면 아무런 일도 일어나지 않는다.
